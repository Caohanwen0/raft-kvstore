### High Level Approach
This project was extremely difficult, we read the paper many times and we still dont fully understand it but were able to implement most things. As a start, the entry point of the program lives within run(), this will iterate forever as the code is located within a while True block. At each point, we see if a heartbeat has missed, meaning the time passed has exceeded our timeout. If it has not been missed, we will skip directly to the handler which will handle every form of message and redirect it to the current function. Each function is written as follows. For each get message, we first check to see if the current state is the leader, if it is we generate a message and store the message within our database, if the current self is not the leader we should redirect to the leader, or if the current leader is unkown we should do a broadcase message. For the put requests, we check to see if the current state is the leader and the message isnt empty, if the message was already in our messages timer and the time difference exceeded one, we will send out a broadcasted failed message. If the message is not in the message timer we will just set that time to the current time. If the put request was a leader then we should append the request to the log, if the leader is unkown then we should store this message into a queue awaiting for the next leader to be elected, otherwise if none of these conditions pass we will resort to redirecting the message to the leader. The put and get requests are the main forms of messages and everything else will be redirected appropriately. If the heartbeat has exceeeded our timeout, then we know that the current leader is down and we must elect a new leader. This is when the new election process beegins, first we will increment the term and request votes from every replica, a replica will be granted a vote if their term is up to date, their log is up to date. If they do not meet these requirements, a vote will not be granted to them and instead a reject_vote message will be sent out. This is the high level approach to our implementation of raft.


### Challenges
The biggest challenges we faced was simply understanding the Raft paper entirely, the wording felt extremely tricky to us and we had to read it over and over again. Though, most things were relatively straight forward we were not able to pass the advanced test cases in its entirety as we had trouble implementing 5.4.2, we went to the TAs multiple times and even they were confused as to how it worked. Simply understanding the Raft paper was the trickiest part.

### Overview of Testing
For testing, we just ran it on our own machines against the multiple test cases. We ran it multiple times since it seemed like we were getting different outputs each time. Whenever we ran into a bug, we would just look over the output of the program and trace back to exactly where it went wrong by adding a bunch of print statements.